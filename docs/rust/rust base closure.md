# rust base closure

> 내부 함수가 종료된 외부 함수의 변수를 참조하는 메커니즘
>
> > 러스트의 익명함수\*는 자신이 정의된 스코프(렉시컬 스코프)에 정의된 값들을 캡처한다. (일반 함수로는 불가능)
> >
> > > 캡처를 하지 않을거라면 일반 함수를 사용해라 (메모리를 잡아먹는다.)

## 클로저 사용 이유

> 클로저는 메모리 차원에서 손해를 볼 수 있지만 이점이 많다.

1. 상태유지: 현재 상태를 기억하고 변경된 최신 상태를 유지할 수 있다.
2. 전역 변수 사용 억제: 상태 변경이나 가변 데이터를 피하고 오류를 피하는 안정성을 증가 시킬 수 있다.
3. 정보 은닉: private 효과를 낼 수 있다.

## JS example

> 자바스크립트는 모든 함수가(일반함수든 화살표함수든..) 상위 스코프를 모두 기억함으로 모든 함수가 클로저다.
>
> > 하지만 브라우저 엔진이 상위 스코프를 참조하지 않는 경우에 최적화를 통해 상위 스코프를 기억하지 않게 한다. (메모리 낭비니까..)
> >
> > > 러스트같은 경우에는 이러한 최적화를 하지 않으므로 사용 시 주의해야한다.

```rs
const hello = (name) => {
  let _name = name;
  return () => { // 리턴하는 함수는 _name을 기억한다.
    console.log("Hello, " + _name);
  };
};

let hello1 = hello("sb"); // 리턴받은 함수를 변수에 저장해도 _name의 값은 남아있다.

hello1(); // Hello, sb
```

## rust 클로저

> 표준 라이브러리는 Fn, FnMut, FnOnce 트레잇을 제공하고 모든 클로저는 이 트레잇 중 하나를 구현한다.

### 리터럴

```rs
|x| ..;

|x|{..};
```

### usage

> 같은 스코프에 선언된(변수 x)의 값을 참조할 수 있다.

```rs
fn main() {
    let x = 4;

    let equal_to_x = |z| z==x; // closure(익명 함수)는 같은 스코프에 선언된(변수 x)의 값을 참조할 수 있다.

    let y = 4;

    println!("{}", equal_to_x(y)); // true
}
```

> 변수 x를 참조할 수 없다. 하려면 x값도 같이 넣어줘야한다.

```rs
fn main() {
    let x = 4;

    fn equal_to_x(z:i32)-> bool {
        z==x // ERROR 변수 x를 참조할 수 없다. 하려면 x값도 같이 넣어줘야한다.
    }

    let y = 4;

    println!("{}", equal_to_x(y)); // true
}
```

> 이런 방식으로

```rs
fn main() {
    let x = 4;

    fn equal_to_x(x:i32, z:i32)-> bool {
        z==x // 변수 x를 참조할 수 없다. 하려면 x값도 같이 넣어줘야한다.
    }

    let y = 4;

    println!("{}", equal_to_x(x, y)); // true
}
```
