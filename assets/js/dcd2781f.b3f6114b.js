"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([["44975"],{505384:function(e,r,n){n.r(r),n.d(r,{frontMatter:()=>i,toc:()=>l,default:()=>d,metadata:()=>t,assets:()=>c,contentTitle:()=>a});var t=JSON.parse('{"id":"protocol/L7 MCP mcp-framework client - http-stream & sse","title":"MCP mcp-framework client","description":"http-stream-client","source":"@site/docs/protocol/L7 MCP mcp-framework client - http-stream & sse.md","sourceDirName":"protocol","slug":"/protocol/L7 MCP mcp-framework client - http-stream & sse","permalink":"/docs/protocol/L7 MCP mcp-framework client - http-stream & sse","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"base MCP init","permalink":"/docs/protocol/L7 MCP initialize"},"next":{"title":"MCP mcp-framework server","permalink":"/docs/protocol/L7 MCP mcp-framework server"}}'),s=n(447259),o=n(255511);let i={},a="MCP mcp-framework client",c={},l=[{value:"http-stream-client",id:"http-stream-client",level:2},{value:"usage",id:"usage",level:2}];function p(e){let r={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"mcp-mcp-framework-client",children:"MCP mcp-framework client"})}),"\n",(0,s.jsx)(r.h2,{id:"http-stream-client",children:"http-stream-client"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:'/**\r\n * Basic client for the HTTP Stream Transport\r\n */\r\nclass HttpStreamClient {\r\n  private baseUrl: string;\r\n  private sessionId: string | null = null;\r\n  private eventSource: EventSource | null = null;\r\n\r\n  constructor(baseUrl: string) {\r\n    this.baseUrl = baseUrl;\r\n  }\r\n\r\n  async initialize() {\r\n    // Create initialization request\r\n    const initRequest = {\r\n      jsonrpc: "2.0",\r\n      id: "init-" + Date.now(),\r\n      method: "initialize",\r\n      params: {\r\n        /* initialization parameters */\r\n      },\r\n    };\r\n\r\n    // Send initialize request\r\n    const response = await fetch(this.baseUrl, {\r\n      method: "POST",\r\n      headers: {\r\n        "Content-Type": "application/json",\r\n        Accept: "application/json, text/event-stream",\r\n      },\r\n      body: JSON.stringify(initRequest),\r\n    });\r\n\r\n    // Get session ID from response headers\r\n    this.sessionId = response.headers.get("Mcp-Session-Id");\r\n    console.log(`Session established: ${this.sessionId}`);\r\n\r\n    // Process the response\r\n    if (response.headers.get("Content-Type")?.includes("text/event-stream")) {\r\n      // Handle streaming response\r\n      this.processStream(response);\r\n    } else {\r\n      // Handle JSON response\r\n      const result = await response.json();\r\n      console.log("Initialization result:", result);\r\n    }\r\n\r\n    // Open SSE stream for server-to-client messages\r\n    this.openEventStream();\r\n  }\r\n\r\n  private openEventStream() {\r\n    const url = new URL(this.baseUrl);\r\n    if (this.sessionId) {\r\n      url.searchParams.append("session", this.sessionId);\r\n    }\r\n\r\n    this.eventSource = new EventSource(url.toString());\r\n\r\n    this.eventSource.onmessage = event => {\r\n      try {\r\n        const message = JSON.parse(event.data);\r\n        console.log("Received SSE message:", message);\r\n        // Process message...\r\n      } catch (e) {\r\n        console.error("Error parsing SSE message:", e);\r\n      }\r\n    };\r\n\r\n    this.eventSource.onerror = error => {\r\n      console.error("SSE connection error:", error);\r\n      this.reconnectEventStream();\r\n    };\r\n\r\n    console.log("SSE stream opened");\r\n  }\r\n\r\n  private reconnectEventStream() {\r\n    if (this.eventSource) {\r\n      this.eventSource.close();\r\n      this.eventSource = null;\r\n    }\r\n\r\n    setTimeout(() => this.openEventStream(), 1000);\r\n  }\r\n\r\n  private async processStream(response: Response) {\r\n    const reader = response.body?.getReader();\r\n    if (!reader) return;\r\n\r\n    const decoder = new TextDecoder();\r\n    let buffer = "";\r\n\r\n    try {\r\n      while (true) {\r\n        const { done, value } = await reader.read();\r\n        if (done) break;\r\n\r\n        buffer += decoder.decode(value, { stream: true });\r\n\r\n        // Process SSE events in buffer\r\n        const events = buffer.split("\\n\\n");\r\n        buffer = events.pop() || "";\r\n\r\n        for (const event of events) {\r\n          const lines = event.split("\\n");\r\n          const data = lines.find(line => line.startsWith("data:"))?.slice(5);\r\n\r\n          if (data) {\r\n            try {\r\n              const message = JSON.parse(data);\r\n              console.log("Received stream message:", message);\r\n              // Process message...\r\n            } catch (e) {\r\n              console.error("Error parsing stream message:", e);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.error("Error reading stream:", e);\r\n    }\r\n  }\r\n\r\n  async sendRequest(method: string, params: any = {}) {\r\n    if (!this.sessionId) {\r\n      throw new Error("Session not initialized");\r\n    }\r\n\r\n    const request = {\r\n      jsonrpc: "2.0",\r\n      id: method + "-" + Date.now(),\r\n      method,\r\n      params,\r\n    };\r\n\r\n    const response = await fetch(this.baseUrl, {\r\n      method: "POST",\r\n      headers: {\r\n        "Content-Type": "application/json",\r\n        Accept: "application/json, text/event-stream",\r\n        "Mcp-Session-Id": this.sessionId,\r\n      },\r\n      body: JSON.stringify(request),\r\n    });\r\n\r\n    if (response.headers.get("Content-Type")?.includes("text/event-stream")) {\r\n      // Handle streaming response\r\n      this.processStream(response);\r\n      return null; // Response will be processed asynchronously\r\n    } else {\r\n      // Handle JSON response\r\n      return await response.json();\r\n    }\r\n  }\r\n\r\n  async terminate() {\r\n    if (!this.sessionId) return;\r\n\r\n    if (this.eventSource) {\r\n      this.eventSource.close();\r\n      this.eventSource = null;\r\n    }\r\n\r\n    try {\r\n      await fetch(this.baseUrl, {\r\n        method: "DELETE",\r\n        headers: {\r\n          "Mcp-Session-Id": this.sessionId,\r\n        },\r\n      });\r\n      console.log("Session terminated");\r\n    } catch (e) {\r\n      console.error("Error terminating session:", e);\r\n    }\r\n\r\n    this.sessionId = null;\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"usage",children:"usage"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:'const httpClient = new HttpStreamClient("http://localhost:8080/mcp");\r\n\r\nawait httpClient.initialize();\r\n\r\nconst res = await httpClient.sendRequest("tools/call", {\r\n  name: "example_tool",\r\n  arguments: {\r\n    message: "Hello World!",\r\n  },\r\n});\r\n\r\nconsole.log(res[0].result);\n'})})]})}function d(e={}){let{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},255511:function(e,r,n){n.d(r,{R:()=>i,x:()=>a});var t=n(596363);let s={},o=t.createContext(s);function i(e){let r=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);