"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[491326],{393221:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"go/go http3 quic-go","title":"go http3 quic-go","description":"install","source":"@site/docs/go/go http3 quic-go.md","sourceDirName":"go","slug":"/go/go http3 quic-go","permalink":"/docs/go/go http3 quic-go","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"go http2","permalink":"/docs/go/go http2"},"next":{"title":"go nodejs ffi","permalink":"/docs/go/go nodejs cgo"}}');var o=n(447259),i=n(529087);const a={},c="go http3 quic-go",s={},l=[{value:"install",id:"install",level:2},{value:"usage",id:"usage",level:2}];function g(r){const e={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,i.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"go-http3-quic-go",children:"go http3 quic-go"})}),"\n",(0,o.jsx)(e.h2,{id:"install",children:"install"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-sh",children:"go get -u github.com/lucas-clemente/quic-go\n"})}),"\n",(0,o.jsx)(e.h2,{id:"usage",children:"usage"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-go",children:'package main\r\n\r\nimport (\r\n "context"\r\n "crypto/rand"\r\n "crypto/rsa"\r\n "crypto/tls"\r\n "crypto/x509"\r\n "encoding/pem"\r\n "fmt"\r\n "io"\r\n "log"\r\n "math/big"\r\n\r\n "github.com/quic-go/quic-go"\r\n)\r\n\r\nconst addr = "localhost:4242"\r\n\r\nconst message = "foobar"\r\n\r\n// We start a server echoing data on the first stream the client opens,\r\n// then connect with a client, send the message, and wait for its receipt.\r\nfunc main() {\r\n go func() { log.Fatal(echoServer()) }()\r\n\r\n err := clientMain()\r\n if err != nil {\r\n  panic(err)\r\n }\r\n}\r\n\r\n// Start a server that echos all data on the first stream opened by the client\r\nfunc echoServer() error {\r\n listener, err := quic.ListenAddr(addr, generateTLSConfig(), nil)\r\n if err != nil {\r\n  return err\r\n }\r\n defer listener.Close()\r\n\r\n conn, err := listener.Accept(context.Background())\r\n if err != nil {\r\n  return err\r\n }\r\n\r\n stream, err := conn.AcceptStream(context.Background())\r\n if err != nil {\r\n  panic(err)\r\n }\r\n defer stream.Close()\r\n\r\n // Echo through the loggingWriter\r\n _, err = io.Copy(loggingWriter{stream}, stream)\r\n return err\r\n}\r\n\r\nfunc clientMain() error {\r\n tlsConf := &tls.Config{\r\n  InsecureSkipVerify: true,\r\n  NextProtos:         []string{"quic-echo-example"},\r\n }\r\n conn, err := quic.DialAddr(context.Background(), addr, tlsConf, nil)\r\n if err != nil {\r\n  return err\r\n }\r\n defer conn.CloseWithError(0, "")\r\n\r\n stream, err := conn.OpenStreamSync(context.Background())\r\n if err != nil {\r\n  return err\r\n }\r\n defer stream.Close()\r\n\r\n fmt.Printf("Client: Sending \'%s\'\\n", message)\r\n _, err = stream.Write([]byte(message))\r\n if err != nil {\r\n  return err\r\n }\r\n\r\n buf := make([]byte, len(message))\r\n _, err = io.ReadFull(stream, buf)\r\n if err != nil {\r\n  return err\r\n }\r\n fmt.Printf("Client: Got \'%s\'\\n", buf)\r\n\r\n return nil\r\n}\r\n\r\n// A wrapper for io.Writer that also logs the message.\r\ntype loggingWriter struct{ io.Writer }\r\n\r\nfunc (w loggingWriter) Write(b []byte) (int, error) {\r\n fmt.Printf("Server: Got \'%s\'\\n", string(b))\r\n return w.Writer.Write(b)\r\n}\r\n\r\n// Setup a bare-bones TLS config for the server\r\nfunc generateTLSConfig() *tls.Config {\r\n key, err := rsa.GenerateKey(rand.Reader, 1024)\r\n if err != nil {\r\n  panic(err)\r\n }\r\n template := x509.Certificate{SerialNumber: big.NewInt(1)}\r\n certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &key.PublicKey, key)\r\n if err != nil {\r\n  panic(err)\r\n }\r\n keyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(key)})\r\n certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})\r\n\r\n tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)\r\n if err != nil {\r\n  panic(err)\r\n }\r\n return &tls.Config{\r\n  Certificates: []tls.Certificate{tlsCert},\r\n  NextProtos:   []string{"quic-echo-example"},\r\n }\r\n}\n'})})]})}function u(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(g,{...r})}):g(r)}},529087:(r,e,n)=>{n.d(e,{R:()=>a,x:()=>c});var t=n(596363);const o={},i=t.createContext(o);function a(r){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function c(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:a(r.components),t.createElement(i.Provider,{value:e},r.children)}}}]);