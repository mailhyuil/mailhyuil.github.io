"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[447589],{529087:(r,t,e)=>{e.d(t,{R:()=>o,x:()=>u});var n=e(596363);const a={},s=n.createContext(a);function o(r){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof r?r(t):{...t,...r}},[t,r])}function u(r){let t;return t=r.disableParentContext?"function"==typeof r.components?r.components(a):r.components||a:o(r.components),n.createElement(s.Provider,{value:t},r.children)}},740799:(r,t,e)=>{e.r(t),e.d(t,{assets:()=>i,contentTitle:()=>u,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"ai langchain/langchain respond Output Parsers StructuredOutputParser","title":"langchain Output Parsers StructuredOutputParser","description":"","source":"@site/docs/ai langchain/langchain respond Output Parsers StructuredOutputParser.md","sourceDirName":"ai langchain","slug":"/ai langchain/langchain respond Output Parsers StructuredOutputParser","permalink":"/docs/ai langchain/langchain respond Output Parsers StructuredOutputParser","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"langchain Output Parsers StringOutputParser","permalink":"/docs/ai langchain/langchain respond Output Parsers StringOutputParser"},"next":{"title":"langchain settings hugging face","permalink":"/docs/ai langchain/langchain \uc138\ud305 settings hugging face"}}');var a=e(447259),s=e(529087);const o={},u="langchain Output Parsers StructuredOutputParser",i={},c=[];function p(r){const t={code:"code",h1:"h1",header:"header",pre:"pre",...(0,s.R)(),...r.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"langchain-output-parsers-structuredoutputparser",children:"langchain Output Parsers StructuredOutputParser"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { z } from "zod";\r\nimport { StructuredOutputParser } from "langchain/output_parsers";\r\nimport { ChatPromptTemplate } from "@langchain/core/prompts";\r\n\r\nlet personSchema = z\r\n  .object({\r\n    name: z.optional(z.string()).describe("The name of the person"),\r\n    hair_color: z.optional(z.string()).describe("The color of the person\'s hair, if known"),\r\n    height_in_meters: z.optional(z.string()).describe("Height measured in meters"),\r\n  })\r\n  .describe("Information about a person.");\r\n\r\nconst parser = StructuredOutputParser.fromZodSchema(personSchema);\r\n\r\nconst prompt = ChatPromptTemplate.fromMessages([\r\n  ["system", "Answer the user query. Wrap the output in `json` tags\\n{format_instructions}"],\r\n  ["human", "{query}"],\r\n]);\r\n\r\nconst partialedPrompt = await prompt.partial({\r\n  format_instructions: parser.getFormatInstructions(),\r\n});\n'})})]})}function l(r={}){const{wrapper:t}={...(0,s.R)(),...r.components};return t?(0,a.jsx)(t,{...r,children:(0,a.jsx)(p,{...r})}):p(r)}}}]);