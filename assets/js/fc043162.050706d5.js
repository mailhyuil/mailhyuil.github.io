"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([["988887"],{713785:function(e,r,n){n.r(r),n.d(r,{frontMatter:()=>a,toc:()=>c,default:()=>u,metadata:()=>s,assets:()=>d,contentTitle:()=>i});var s=JSON.parse('{"id":"x design pattern/Behavioral mediator example","title":"mediator pattern example","description":"","source":"@site/docs/x design pattern/Behavioral mediator example.md","sourceDirName":"x design pattern","slug":"/x design pattern/Behavioral mediator example","permalink":"/docs/x design pattern/Behavioral mediator example","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"iterator","permalink":"/docs/x design pattern/Behavioral iterator"},"next":{"title":"mediator pattern (\uC911\uC7AC\uC790 \uD328\uD134)","permalink":"/docs/x design pattern/Behavioral mediator"}}'),t=n(447259),o=n(255511);let a={},i="mediator pattern example",d={},c=[];function m(e){let r={code:"code",h1:"h1",header:"header",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"mediator-pattern-example",children:"mediator pattern example"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",children:'// message type\r\ntype ReadMessage = {\r\n  type: "memory-read";\r\n  address: number;\r\n  response: (value: number) => void;\r\n};\r\n\r\n// message type\r\ntype WriteMessage = {\r\n  type: "memory-write";\r\n  value: number;\r\n  address: number;\r\n  response: (wasOk: boolean) => void;\r\n};\r\n\r\n// message type\r\ntype CPUMemoryMessages = ReadMessage | WriteMessage;\r\n\r\n// Mediator interface\r\ninterface Bus<Messages> {\r\n  notify(message: Messages): void;\r\n}\r\n\r\n// Concrete Mediator\r\nclass DataBus implements Bus<CPUMemoryMessages> {\r\n  private cpu: CPU;\r\n  private memory: Memory;\r\n\r\n  constructor(cpu: CPU, memory: Memory) {\r\n    this.cpu = cpu;\r\n    this.memory = memory;\r\n\r\n    // setup the connections\r\n    this.cpu.connect(this);\r\n    this.memory.connect(this);\r\n  }\r\n\r\n  notify(message: CPUMemoryMessages): void {\r\n    switch (message.type) {\r\n      case "memory-read": {\r\n        const { address, response } = message;\r\n        const value = this.memory.read(address);\r\n        response(value);\r\n        break;\r\n      }\r\n      case "memory-write": {\r\n        const { address, value, response } = message;\r\n        try {\r\n          this.memory.write(value, address);\r\n          response(true); // writing operation success\r\n        } catch (e) {\r\n          response(false); // there was an error\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        throw new Error("Invalid message");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Colleague\r\nexport class BusConnector<TMessages> {\r\n  private bus: Bus<TMessages> | undefined;\r\n\r\n  connect(bus: Bus<TMessages>) {\r\n    this.bus = bus;\r\n  }\r\n\r\n  signal(message: TMessages) {\r\n    if (!this.bus) {\r\n      throw new Error("bus disconnected");\r\n    }\r\n\r\n    this.bus.notify(message);\r\n  }\r\n}\r\n\r\n// Concrete Colleague\r\nclass Memory extends BusConnector<CPUMemoryMessages> {\r\n  private memory: number[];\r\n\r\n  constructor() {\r\n    super();\r\n    this.memory = [];\r\n  }\r\n\r\n  read(address: number): number {\r\n    console.log(`Memory: reading the address (${address})`);\r\n    return this.memory[address];\r\n  }\r\n\r\n  write(value: number, address: number) {\r\n    console.log(`Memory: writing the value (${value}) on address (${address})`);\r\n    this.memory[address] = value;\r\n  }\r\n}\r\n\r\n// Concrete Colleague\r\nclass CPU extends BusConnector<CPUMemoryMessages> {\r\n  private nextInstructionAddress: number = 0;\r\n  private result: number = 0;\r\n\r\n  fetch() {\r\n    console.log(`CPU: Triying to fetch an instruction from address ${this.nextInstructionAddress}`);\r\n\r\n    let instruction: number;\r\n\r\n    this.signal({\r\n      type: "memory-read",\r\n      address: this.nextInstructionAddress,\r\n      response: (value) => (instruction = value),\r\n    });\r\n\r\n    console.log(`CPU: instruction fetched from address ${this.nextInstructionAddress}`);\r\n\r\n    // - Increment the nextInstructionAddress\r\n    this.nextInstructionAddress++;\r\n  }\r\n\r\n  decode(instruction: number) {\r\n    // Not implemented for sake of simplicity\r\n  }\r\n\r\n  execute(opCode: number, operand1: number, operand2: number) {\r\n    // run the code associated with the decoded instruction\r\n    switch (opCode) {\r\n      case 0:\r\n        this.result = operand1 + operand2;\r\n        break;\r\n      case 1:\r\n        this.result = operand1 / operand2;\r\n        break;\r\n      case 2:\r\n        console.log(`CPU: Triying write a value on address ${operand2}`);\r\n\r\n        this.signal({\r\n          type: "memory-write",\r\n          value: operand1,\r\n          address: operand2,\r\n          response: (ok) => console.log(`CPU: write operation success: ${ok}`),\r\n        });\r\n        break;\r\n      // ... rest of operations\r\n      default: {\r\n        throw new Error("Invalid operation");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst cpu = new CPU();\r\nconst memory = new Memory();\r\nconst bus = new DataBus(cpu, memory);\r\n\r\ncpu.fetch();\r\ncpu.fetch();\r\ncpu.execute(2, 4, 10);\n'})})]})}function u(e={}){let{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},255511:function(e,r,n){n.d(r,{R:()=>a,x:()=>i});var s=n(596363);let t={},o=s.createContext(t);function a(e){let r=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(o.Provider,{value:r},e.children)}}}]);