"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[774507],{37931:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"x design pattern/Behavioral Chain of Responsibility - CoR vs decorator","title":"design pattern CoR vs Decorator","description":"","source":"@site/docs/x design pattern/Behavioral Chain of Responsibility - CoR vs decorator.md","sourceDirName":"x design pattern","slug":"/x design pattern/Behavioral Chain of Responsibility - CoR vs decorator","permalink":"/docs/x design pattern/Behavioral Chain of Responsibility - CoR vs decorator","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"design pattern CoR example Express","permalink":"/docs/x design pattern/Behavioral Chain of Responsibility - CoR example express"},"next":{"title":"chain of responsibility (\ucc45\uc784 \uc5f0\uc1c4 \ud328\ud134)","permalink":"/docs/x design pattern/Behavioral Chain of Responsibility - CoR"}}');var o=t(447259),s=t(529087);const r={},a="design pattern CoR vs Decorator",l={},c=[];function p(e){const n={code:"code",h1:"h1",header:"header",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"design-pattern-cor-vs-decorator",children:"design pattern CoR vs Decorator"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-txt",children:'I generally think of the Decorator as "adding" to some thing, where as Chain of Responsiblity is more like handling something thing.\r\n\r\nIn comparing the two patterns (besides being apples and oranges) the biggest difference is the Chain of Responsibility can kill the chain at any point.\r\n\r\nThink of decorators as a layered unit in which each layer always does pre/post processing. Chain of Responsibility is more like a linked list, and generally 1 thing handles processing.\r\n\r\nThe Chain of Responsibility pattern allows for multiple things to handle an event but it also gives them the opportunity to terminate the chain at any point.\n'})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},529087:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(596363);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);