"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[949160],{529087:(n,e,a)=>{a.d(e,{R:()=>o,x:()=>s});var l=a(596363);const r={},t=l.createContext(r);function o(n){const e=l.useContext(t);return l.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),l.createElement(t.Provider,{value:e},n.children)}},825529:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>i});const l=JSON.parse('{"id":"nodejs/nodejs race condition","title":"nodejs race condition","description":"nodejs\ub294 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8(cpu)\ub97c \uc2f1\uae00 \uc2a4\ub808\ub4dc\uc5d0\uc11c \ub3cc\ub9ac\uae30 \ub54c\ubb38\uc5d0 \uc5f0\uc0b0\uc73c\ub85c \uc778\ud55c race condition \ubc84\uadf8\ub294 \ubc1c\uc0dd\ud558\uc9c0 \uc54a\ub294\ub2e4.","source":"@site/docs/nodejs/nodejs race condition.md","sourceDirName":"nodejs","slug":"/nodejs/nodejs race condition","permalink":"/docs/nodejs/nodejs race condition","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"mutex vs distributed-lock","permalink":"/docs/nodejs/nodejs race condition mutex vs distributed-lock"},"next":{"title":"nodejs redis","permalink":"/docs/nodejs/nodejs redis"}}');var r=a(447259),t=a(529087);const o={},s="nodejs race condition",c={},i=[{value:"problem",id:"problem",level:2},{value:"solution",id:"solution",level:2},{value:"install",id:"install",level:3}];function d(n){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"nodejs-race-condition",children:"nodejs race condition"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"nodejs\ub294 \uc790\ubc14\uc2a4\ud06c\ub9bd\ud2b8(cpu)\ub97c \uc2f1\uae00 \uc2a4\ub808\ub4dc\uc5d0\uc11c \ub3cc\ub9ac\uae30 \ub54c\ubb38\uc5d0 \uc5f0\uc0b0\uc73c\ub85c \uc778\ud55c race condition \ubc84\uadf8\ub294 \ubc1c\uc0dd\ud558\uc9c0 \uc54a\ub294\ub2e4."}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"\ud558\uc9c0\ub9cc \ube44\ub3d9\uae30 task(I/O)\ub97c \ubc31\uadf8\ub77c\uc6b4\ub4dc \uba40\ud2f0 \uc2a4\ub808\ub4dc\uc5d0\uc11c \ub3cc\ub9ac\uae30 \ub54c\ubb38\uc5d0 \uc21c\uc11c\ub85c \uc778\ud55c race condition \ubc84\uadf8\uac00 \ubc1c\uc0dd\ud560 \uc218 \uc788\ub2e4."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"problem",children:"problem"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// Utility function to simulate some delay (e.g. reading from or writing to a database).\r\n// It will take from 0 to 50ms in a random fashion.\r\nconst randomDelay = () => new Promise((resolve) => setTimeout(resolve, Math.random() * 100));\r\n\r\n// Our global balance.\r\n// In a more complete implementation, this will live in the persistent data storage.\r\nlet balance = 0;\r\n\r\nasync function loadBalance() {\r\n  // simulates random delay to retrieve data from data storage\r\n  await randomDelay();\r\n  return balance;\r\n}\r\n\r\nasync function saveBalance(value) {\r\n  // simulates random delay to write the data to the data storage\r\n  await randomDelay();\r\n  balance = value;\r\n}\r\n\r\nasync function sellGrapes() {\r\n  const balance = await loadBalance();\r\n  console.log(`sellGrapes - balance loaded: ${balance}`);\r\n  const newBalance = balance + 50;\r\n  await saveBalance(newBalance);\r\n  console.log(`sellGrapes - balance updated: ${newBalance}`);\r\n}\r\n\r\nasync function sellOlives() {\r\n  const balance = await loadBalance();\r\n  console.log(`sellOlives - balance loaded: ${balance}`);\r\n  const newBalance = balance + 50;\r\n  await saveBalance(newBalance);\r\n  console.log(`sellOlives - balance updated: ${newBalance}`);\r\n}\r\n\r\nasync function main() {\r\n  const transaction1 = sellGrapes(); // NOTE: no `await`\r\n  const transaction2 = sellOlives(); // NOTE: no `await`\r\n  await transaction1; // NOTE: awaiting here does not stop `transaction2`\r\n  // from being scheduled before transaction 1 is completed\r\n  await transaction2;\r\n  const balance = await loadBalance();\r\n  console.log(`Final balance: ${balance}`);\r\n}\r\n\r\nmain();\n"})}),"\n",(0,r.jsx)(e.h2,{id:"solution",children:"solution"}),"\n",(0,r.jsx)(e.h3,{id:"install",children:"install"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-sh",children:"npm i async-mutex\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'import { Mutex } from "async-mutex";\r\n\r\nconst randomDelay = () => {\r\n  /* ... */\r\n};\r\n\r\nlet balance = 0;\r\nconst mutex = new Mutex(); // global mutex instance\r\n\r\nasync function loadBalance() {\r\n  /* ... */\r\n}\r\nasync function saveBalance(value) {\r\n  /* ... */\r\n}\r\n\r\nasync function sellGrapes() {\r\n  // this code will need exclusive access to the balance\r\n  // so we consider this to be a critical path\r\n  const release = await mutex.acquire(); // get access to the critical path (or wait in line)\r\n  try {\r\n    const balance = await loadBalance();\r\n    console.log(`sellGrapes - balance loaded: ${balance}`);\r\n    const newBalance = balance + 50;\r\n    await saveBalance(newBalance);\r\n    console.log(`sellGrapes - balance updated: ${newBalance}`);\r\n  } finally {\r\n    release(); // completes work on the critical path\r\n  }\r\n}\r\n\r\nasync function sellOlives() {\r\n  // similar to `sellGrapes` this is a critical path because\r\n  // it needs exclusive access to balance\r\n  const release = await mutex.acquire();\r\n  try {\r\n    const balance = await loadBalance();\r\n    console.log(`sellOlives - balance loaded: ${balance}`);\r\n    const newBalance = balance + 50;\r\n    await saveBalance(newBalance);\r\n    console.log(`sellOlives - balance updated: ${newBalance}`);\r\n  } finally {\r\n    release();\r\n  }\r\n}\r\n\r\nasync function main() {\r\n  // Here we can call many events safely, the mutex will guarantee that the\r\n  // competing events are executed in the right order!\r\n  await Promise.all([sellGrapes(), sellOlives(), sellGrapes(), sellOlives(), sellGrapes(), sellOlives()]);\r\n  const balance = await loadBalance();\r\n  console.log(`Final balance: ${balance}`);\r\n}\r\n\r\nmain();\n'})})]})}function u(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);