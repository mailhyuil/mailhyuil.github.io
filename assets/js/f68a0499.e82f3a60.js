"use strict";(self.webpackChunkmy_blog=self.webpackChunkmy_blog||[]).push([["908765"],{691146:function(r,e,n){n.r(e),n.d(e,{frontMatter:()=>i,toc:()=>d,default:()=>p,metadata:()=>o,assets:()=>c,contentTitle:()=>a});var o=JSON.parse('{"id":"nestjs/nest auth jwt \uC778\uC99D \uB85C\uC9C1","title":"nestjs jwt","description":"auth.dto.ts","source":"@site/docs/nestjs/nest auth jwt \uC778\uC99D \uB85C\uC9C1.md","sourceDirName":"nestjs","slug":"/nestjs/nest auth jwt \uC778\uC99D \uB85C\uC9C1","permalink":"/docs/nestjs/nest auth jwt \uC778\uC99D \uB85C\uC9C1","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"nest jwt scenario","permalink":"/docs/nestjs/nest auth jwt scenario"},"next":{"title":"nestjs jwt","permalink":"/docs/nestjs/nest auth jwt"}}'),t=n(447259),s=n(255511);let i={},a="nestjs jwt",c={},d=[{value:"auth.dto.ts",id:"authdtots",level:2},{value:"auth.controller.ts",id:"authcontrollerts",level:2},{value:"auth.service.ts",id:"authservicets",level:2},{value:"auth.guard.ts",id:"authguardts",level:2},{value:"get-user.decorator.ts",id:"get-userdecoratorts",level:2},{value:"id-token.guard.ts",id:"id-tokenguardts",level:2}];function l(r){let e={code:"code",h1:"h1",h2:"h2",header:"header",pre:"pre",...(0,s.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"nestjs-jwt",children:"nestjs jwt"})}),"\n",(0,t.jsx)(e.h2,{id:"authdtots",children:"auth.dto.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";\r\nimport { Provider, UserStatus } from "@prisma/client";\r\nimport { Type } from "class-transformer";\r\nimport { IsNotEmpty, IsString } from "class-validator";\r\nimport { UserDTO } from "../user/user.dto";\r\n\r\nexport class AuthenticationDTO {\r\n  @ApiProperty()\r\n  readonly id: string;\r\n  @ApiProperty({\r\n    enum: Provider,\r\n  })\r\n  readonly provider: Provider;\r\n  @ApiPropertyOptional()\r\n  readonly providerId?: string;\r\n  @ApiProperty({ type: "Date" })\r\n  readonly createdAt: Date;\r\n  @ApiProperty({ type: "Date" })\r\n  readonly updatedAt: Date;\r\n\r\n  @ApiProperty({\r\n    type: () => UserDTO,\r\n  })\r\n  @Type(() => UserDTO)\r\n  readonly user: UserDTO;\r\n  @ApiProperty()\r\n  readonly userId: string;\r\n}\r\n\r\nexport class LoginDTO {\r\n  @ApiProperty()\r\n  @IsNotEmpty({ message: "\uC0AC\uC6A9\uC790 \uC774\uB984\uC740 \uD544\uC218\uC785\uB2C8\uB2E4." })\r\n  @IsString({ message: "\uC0AC\uC6A9\uC790 \uC774\uB984\uC740 \uBB38\uC790\uC5F4\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4." })\r\n  readonly username: string;\r\n  @ApiProperty()\r\n  @IsNotEmpty({ message: "\uBE44\uBC00\uBC88\uD638\uB294 \uD544\uC218\uC785\uB2C8\uB2E4." })\r\n  @IsString({ message: "\uBE44\uBC00\uBC88\uD638\uB294 \uBB38\uC790\uC5F4\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4." })\r\n  readonly password: string;\r\n}\r\n\r\nexport class LoginResponseDTO {\r\n  @ApiProperty()\r\n  readonly idToken: string;\r\n  @ApiProperty()\r\n  readonly refreshToken: string;\r\n}\r\n\r\nexport type IdTokenPayload = {\r\n  id: string;\r\n  roles: string[];\r\n  status: UserStatus;\r\n};\r\n\r\nexport type RefreshTokenPayload = {\r\n  id: string;\r\n};\n'})}),"\n",(0,t.jsx)(e.h2,{id:"authcontrollerts",children:"auth.controller.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { Body, Controller, Get, Post, Req, Res, UnauthorizedException } from "@nestjs/common";\r\nimport { ApiBody, ApiNoContentResponse, ApiOperation, ApiTags } from "@nestjs/swagger";\r\nimport { type Request, type Response } from "express";\r\nimport { LoginDTO } from "./auth.dto";\r\nimport { AuthService } from "./auth.service";\r\nimport { idTokenOptions, loggedInOptions, refreshTokenOptions } from "./token/token-cookie-options";\r\n\r\n@ApiTags("Auth")\r\n@Controller({ path: "auth", version: "1" })\r\nexport class AuthController {\r\n  constructor(private readonly authService: AuthService) {}\r\n\r\n  @Post("login")\r\n  @ApiOperation({\r\n    summary: "\uB85C\uADF8\uC778",\r\n  })\r\n  @ApiBody({ type: LoginDTO })\r\n  @ApiNoContentResponse()\r\n  async login(@Body() body: LoginDTO, @Res({ passthrough: true }) res: Response) {\r\n    const { idToken, refreshToken } = await this.authService.login(body);\r\n    res.cookie("logged-in", true, loggedInOptions);\r\n    res.cookie("id-token", idToken, idTokenOptions);\r\n    res.cookie("refresh-token", refreshToken, refreshTokenOptions);\r\n  }\r\n\r\n  @Get("logout")\r\n  @ApiOperation({\r\n    summary: "\uB85C\uADF8\uC544\uC6C3",\r\n  })\r\n  @ApiNoContentResponse()\r\n  async logout(@Res({ passthrough: true }) res: Response) {\r\n    res.clearCookie("logged-in");\r\n    res.clearCookie("id-token");\r\n    res.clearCookie("refresh-token");\r\n  }\r\n\r\n  @Get("refresh")\r\n  @ApiOperation({\r\n    summary: "\uD1A0\uD070 \uC7AC\uBC1C\uAE09",\r\n  })\r\n  @ApiNoContentResponse()\r\n  async getIdTokenByRefreshToken(@Req() req: Request, @Res({ passthrough: true }) res: Response) {\r\n    const refreshToken = req.cookies["refresh-token"];\r\n    const { idToken, newRefreshToken } = await this.authService.getIdTokenByRefreshToken(refreshToken).catch(err => {\r\n      throw new UnauthorizedException(err.message);\r\n    });\r\n    res.cookie("id-token", idToken, idTokenOptions);\r\n    res.cookie("refresh-token", newRefreshToken, refreshTokenOptions);\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"authservicets",children:"auth.service.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { InvalidTokenException, UserNotFoundException } from "@/server/errors/exception";\r\nimport { Cache, CACHE_MANAGER } from "@nestjs/cache-manager";\r\nimport { Inject, Injectable, Logger, OnModuleInit, UnauthorizedException } from "@nestjs/common";\r\nimport { JsonWebTokenError, JwtService, TokenExpiredError } from "@nestjs/jwt";\r\nimport { PrismaService } from "apps/server/src/prisma/prisma.service";\r\nimport bcrypt from "bcrypt";\r\nimport { plainToInstance } from "class-transformer";\r\nimport { PrismaError } from "prisma-error-enum";\r\nimport { IdTokenPayload, LoginDTO, LoginResponseDTO, RefreshTokenPayload } from "./auth.dto";\r\nimport { IdTokenService, RefreshTokenService } from "./token/token.token";\r\n\r\nconst JWT_REFRESH_TOKEN_EXPIRES_IN = 2592000000; /* 30 days in milliseconds */\r\n\r\n@Injectable()\r\nexport class AuthService implements OnModuleInit {\r\n  private readonly logger = new Logger(AuthService.name);\r\n  constructor(\r\n    private readonly prisma: PrismaService,\r\n    @Inject(IdTokenService)\r\n    private readonly idTokenService: JwtService,\r\n    @Inject(RefreshTokenService)\r\n    private readonly refreshTokenService: JwtService,\r\n    @Inject(CACHE_MANAGER) private readonly cache: Cache,\r\n  ) {}\r\n\r\n  onModuleInit() {\r\n    this.initAdmin();\r\n  }\r\n\r\n  async initAdmin() {\r\n    const username = process.env.ADMIN_USERNAME;\r\n    if (!username) {\r\n      throw new Error("ADMIN_USERNAME \uD658\uACBD\uBCC0\uC218\uAC00 \uC815\uC758\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");\r\n    }\r\n    const password = process.env.ADMIN_PASSWORD;\r\n    if (!password) {\r\n      throw new Error("ADMIN_PASSWORD \uD658\uACBD\uBCC0\uC218\uAC00 \uC815\uC758\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");\r\n    }\r\n    const found = await this.prisma.user.findFirst({\r\n      where: {\r\n        roles: {\r\n          has: "ADMIN",\r\n        },\r\n      },\r\n    });\r\n    if (!found) {\r\n      await this.prisma.user.create({\r\n        data: {\r\n          username,\r\n          password: await bcrypt.hash(password, 10),\r\n          name: "admin",\r\n          birthDate: new Date(),\r\n          roles: ["ADMIN"],\r\n          tel: "010-0000-0000",\r\n          authentications: {\r\n            create: {\r\n              provider: "LOCAL",\r\n            },\r\n          },\r\n        },\r\n      });\r\n      this.logger.log("Admin \uACC4\uC815 \uC0DD\uC131 \uC644\uB8CC");\r\n    }\r\n  }\r\n\r\n  async login(data: LoginDTO) {\r\n    const { username, password } = data;\r\n\r\n    const res = await this.prisma.$transaction(async tx => {\r\n      const found = await tx.user\r\n        .findUniqueOrThrow({\r\n          where: {\r\n            username,\r\n          },\r\n          select: {\r\n            id: true,\r\n            password: true,\r\n            roles: true,\r\n            status: true,\r\n          },\r\n        })\r\n        .catch(error => {\r\n          if (error.code === PrismaError.RecordsNotFound) {\r\n            throw new UserNotFoundException(error);\r\n          }\r\n          throw error;\r\n        });\r\n\r\n      if (!(await bcrypt.compare(password, found.password))) {\r\n        throw new UnauthorizedException("\uC0AC\uC6A9\uC790 \uC815\uBCF4\uB97C \uB2E4\uC2DC \uD655\uC778\uD574\uC8FC\uC138\uC694.");\r\n      }\r\n\r\n      const idTokenPayload: IdTokenPayload = {\r\n        id: found.id,\r\n        roles: found.roles,\r\n        status: found.status,\r\n      };\r\n      const refreshTokenPayload: RefreshTokenPayload = {\r\n        id: found.id,\r\n      };\r\n      const idToken = this.idTokenService.sign(idTokenPayload);\r\n      const refreshToken = this.refreshTokenService.sign(refreshTokenPayload);\r\n\r\n      // ? set refreshToken\r\n      this.cache.set(`refreshToken:${found.id}`, refreshToken, JWT_REFRESH_TOKEN_EXPIRES_IN);\r\n\r\n      return {\r\n        idToken,\r\n        refreshToken,\r\n      };\r\n    });\r\n    return plainToInstance(LoginResponseDTO, res);\r\n  }\r\n\r\n  async getIdTokenByRefreshToken(refreshToken: string) {\r\n    if (!refreshToken) throw new InvalidTokenException();\r\n\r\n    // ? refreshToken \uAC80\uC99D\r\n    let payload: IdTokenPayload;\r\n    try {\r\n      payload = this.refreshTokenService.verify(refreshToken);\r\n    } catch (error) {\r\n      if (error instanceof JsonWebTokenError) {\r\n        //? \uD1A0\uD070\uC774 \uC784\uC758\uB85C \uBCC0\uC870\uB41C \uACBD\uC6B0\r\n        throw new InvalidTokenException();\r\n      } else if (error instanceof TokenExpiredError) {\r\n        //? \uD1A0\uD070\uC758 \uC720\uD6A8\uAE30\uAC04\uC774 \uB9CC\uB8CC\uB41C \uACBD\uC6B0\r\n        throw new InvalidTokenException();\r\n      } else {\r\n        throw new InvalidTokenException();\r\n      }\r\n    }\r\n\r\n    // ? get userRefreshToken\r\n    const userRefreshToken = await this.cache.get<string>(`refreshToken:${payload.id}`);\r\n\r\n    if (!userRefreshToken) throw new InvalidTokenException();\r\n\r\n    // ! userRefreshToken \uAC80\uC99D\r\n    let userPayload: RefreshTokenPayload;\r\n    try {\r\n      userPayload = this.refreshTokenService.verify(userRefreshToken);\r\n    } catch (error) {\r\n      this.cache.del(`refreshToken:${payload.id}`);\r\n      if (error instanceof JsonWebTokenError) {\r\n        //? \uD1A0\uD070\uC774 \uC784\uC758\uB85C \uBCC0\uC870\uB41C \uACBD\uC6B0\r\n        throw new InvalidTokenException();\r\n      } else if (error instanceof TokenExpiredError) {\r\n        //? \uD1A0\uD070\uC758 \uC720\uD6A8\uAE30\uAC04\uC774 \uB9CC\uB8CC\uB41C \uACBD\uC6B0\r\n        throw new InvalidTokenException();\r\n      } else {\r\n        throw new InvalidTokenException();\r\n      }\r\n    }\r\n\r\n    if (userPayload.id !== payload.id) throw new InvalidTokenException();\r\n\r\n    // ? payload.id\uB85C \uC720\uC800 \uC870\uD68C\r\n    const user = await this.prisma.user\r\n      .findUniqueOrThrow({\r\n        where: { id: payload.id },\r\n        select: {\r\n          id: true,\r\n          roles: true,\r\n          status: true,\r\n        },\r\n      })\r\n      .catch(() => {\r\n        throw new InvalidTokenException();\r\n      });\r\n\r\n    const refreshTokenPayload: RefreshTokenPayload = {\r\n      id: user.id,\r\n    };\r\n\r\n    const newRefreshToken = this.refreshTokenService.sign(refreshTokenPayload);\r\n\r\n    // ? refreshToken rotation\r\n    this.cache.set(`refreshToken:${user.id}`, newRefreshToken, JWT_REFRESH_TOKEN_EXPIRES_IN);\r\n\r\n    const idTokenPayload: IdTokenPayload = {\r\n      id: user.id,\r\n      roles: user.roles,\r\n      status: user.status,\r\n    };\r\n\r\n    const idToken = this.idTokenService.sign(idTokenPayload);\r\n\r\n    return { idToken, newRefreshToken };\r\n  }\r\n\r\n  async getUserByIdToken(idToken: string): Promise<IdTokenPayload> {\r\n    return this.idTokenService.verify(idToken);\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"authguardts",children:"auth.guard.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { InvalidTokenException } from "@/server/errors";\r\nimport { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";\r\nimport { JsonWebTokenError, TokenExpiredError } from "@nestjs/jwt";\r\nimport { Request, Response } from "express";\r\nimport { ClsService } from "nestjs-cls";\r\nimport { AuthService } from "../auth.service";\r\n\r\n@Injectable()\r\nexport class AuthGuard implements CanActivate {\r\n  constructor(private readonly cls: ClsService, private readonly authService: AuthService) {}\r\n\r\n  async canActivate(context: ExecutionContext) {\r\n    const req: Request = context.switchToHttp().getRequest();\r\n    const res: Response = context.switchToHttp().getResponse();\r\n    const cookies = req.cookies;\r\n    const idToken = cookies["id-token"];\r\n    if (!idToken) throw new UnauthorizedException();\r\n\r\n    const user = await this.authService.getUserByIdToken(idToken).catch(async error => {\r\n      if (error instanceof JsonWebTokenError) {\r\n        // ? \uD1A0\uD070\uC774 \uC784\uC758\uB85C \uBCC0\uC870\uB41C \uACBD\uC6B0\r\n        res.clearCookie("logged-in");\r\n        res.clearCookie("id-token");\r\n        res.clearCookie("refresh-token");\r\n        throw new InvalidTokenException();\r\n      } else if (error instanceof TokenExpiredError) {\r\n        throw new InvalidTokenException();\r\n      } else {\r\n        throw error;\r\n      }\r\n    });\r\n\r\n    req["user"] = user;\r\n    this.cls.set("user", user);\r\n\r\n    return true;\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"get-userdecoratorts",children:"get-user.decorator.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { createParamDecorator, ExecutionContext } from "@nestjs/common";\r\nimport { IdTokenPayload } from "../auth.dto";\r\ntype UserRecord = keyof IdTokenPayload;\r\nexport const GetUser = createParamDecorator((data: UserRecord, ctx: ExecutionContext) => {\r\n  const req = ctx.switchToHttp().getRequest();\r\n  return data ? req.user?.[data] : req.user;\r\n});\n'})}),"\n",(0,t.jsx)(e.h2,{id:"id-tokenguardts",children:"id-token.guard.ts"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";\r\nimport { Request } from "express";\r\nimport { Observable } from "rxjs";\r\n\r\nconst blacklist = [];\r\n@Injectable()\r\nexport class IdTokenGuard implements CanActivate {\r\n  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {\r\n    const req: Request = context.switchToHttp().getRequest();\r\n    const idToken = req.cookies["id-token"];\r\n    if (blacklist.includes(idToken)) {\r\n      throw new UnauthorizedException("Blocked IdToken");\r\n    }\r\n    return true;\r\n  }\r\n}\n'})})]})}function p(r={}){let{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(l,{...r})}):l(r)}},255511:function(r,e,n){n.d(e,{R:()=>i,x:()=>a});var o=n(596363);let t={},s=o.createContext(t);function i(r){let e=o.useContext(s);return o.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function a(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:i(r.components),o.createElement(s.Provider,{value:e},r.children)}}}]);