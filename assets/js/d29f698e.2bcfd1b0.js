"use strict";(globalThis.webpackChunkmy_blog=globalThis.webpackChunkmy_blog||[]).push([[676342],{529087:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>s});var t=n(596363);const i={},a=t.createContext(i);function o(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:r},e.children)}},569512:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"frontend/webapi WebAuthn - FIDO2 - passwordless","title":"webapi WebAuthn (Web Authentication API) (FIDO2 = Fast IDentity Online)","description":"password \uc5c6\uc774 touch id, face id, security key \ub4f1\uc744 \uc774\uc6a9\ud55c \ub85c\uadf8\uc778\uc744 \uc9c0\uc6d0\ud558\ub294 \uc6f9 API","source":"@site/docs/frontend/webapi WebAuthn - FIDO2 - passwordless.md","sourceDirName":"frontend","slug":"/frontend/webapi WebAuthn - FIDO2 - passwordless","permalink":"/docs/frontend/webapi WebAuthn - FIDO2 - passwordless","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"webapi Web Worker","permalink":"/docs/frontend/webapi Web Worker"},"next":{"title":"webapi WebRTC (Real Time Communication)","permalink":"/docs/frontend/webapi WebRTC - Real Time Communication"}}');var i=n(447259),a=n(529087);const o={},s="webapi WebAuthn (Web Authentication API) (FIDO2 = Fast IDentity Online)",l={},c=[{value:"server",id:"server",level:2},{value:"client",id:"client",level:2}];function u(e){const r={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"webapi-webauthn-web-authentication-api-fido2--fast-identity-online",children:"webapi WebAuthn (Web Authentication API) (FIDO2 = Fast IDentity Online)"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"password \uc5c6\uc774 touch id, face id, security key \ub4f1\uc744 \uc774\uc6a9\ud55c \ub85c\uadf8\uc778\uc744 \uc9c0\uc6d0\ud558\ub294 \uc6f9 API"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"server",children:"server"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:"const webauthn = new WebAuthn({\r\n  origin: process.env.ORIGIN || 'https://example.net',\r\n  usernameField: 'email', // field that uniquely id's user\r\n  userFields: {\r\n    email: 'email',\r\n    name: 'displayName',\r\n  },\r\n  store: {\r\n    // methods to wire up your DB. (Not implemented)\r\n    put: async (id, value) => void,\r\n    get: async (id) => User,\r\n    search: async (search) =>  { [username]: User },\r\n    delete: async (id) => boolean,\r\n  },\r\n  rpName: 'BrieBug Software', // relying party\r\n});\r\n\r\napp.use('/webauthn', webauthn.initialize());\r\n\r\n// check if the user is signed in\r\napp.get('/auth-check', webauthn.authenticate(), (req, res) => {\r\n  res.status(200).json({ status: 'ok'});\r\n});\n"})}),"\n",(0,i.jsx)(r.h2,{id:"client",children:"client"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-ts",children:'import { Injectable } from "@angular/core";\r\n\r\n@Injectable({\r\n  providedIn: "root",\r\n})\r\nexport class WebAuthnService {\r\n  constructor() {}\r\n\r\n  // Generates a random buffer to use as a challenge, which is a unique value needed for security\r\n  private generateRandomBuffer(length: number): Uint8Array {\r\n    const randomBuffer = new Uint8Array(length);\r\n    window.crypto.getRandomValues(randomBuffer); // Fills the buffer with cryptographically secure random values\r\n    return randomBuffer;\r\n  }\r\n\r\n  // Registers a new credential (like a fingerprint or Face ID) for the user\r\n  async register() {\r\n    // Generate a unique challenge for the registration process\r\n    const challenge = this.generateRandomBuffer(32);\r\n\r\n    // PublicKeyCredentialCreationOptions is the core object needed for registration\r\n    const publicKey: PublicKeyCredentialCreationOptions = {\r\n      challenge: challenge, // A random value generated by the server to ensure the request is fresh and unique\r\n      rp: {\r\n        // Relying Party (your app) information\r\n        name: "OurAwesomeApp", // Display name of your app\r\n      },\r\n      user: {\r\n        // User information\r\n        id: this.generateRandomBuffer(16), // A unique identifier for the user\r\n        name: "user@example.com", // User\'s email or username\r\n        displayName: "User Example", // A friendly name for the user\r\n      },\r\n      pubKeyCredParams: [\r\n        {\r\n          // Array of acceptable public key algorithms\r\n          type: "public-key",\r\n          alg: -7, // Represents the ES256 algorithm (Elliptic Curve Digital Signature Algorithm)\r\n        },\r\n      ],\r\n      authenticatorSelection: {\r\n        // Criteria for selecting the appropriate authenticator\r\n        authenticatorAttachment: "platform", // Ensures we use the device\'s built-in biometric authenticator like Touch ID or Face ID\r\n        userVerification: "required", // Requires user verification (e.g., fingerprint or face scan)\r\n      },\r\n      timeout: 60000, // Timeout for the registration operation in milliseconds\r\n      attestation: "direct", // Attestation provides proof of the authenticator\'s properties and is sent back to the server\r\n    };\r\n\r\n    try {\r\n      // This will prompt the user to register their biometric credential\r\n      const credential = (await navigator.credentials.create({ publicKey })) as PublicKeyCredential;\r\n      this.storeCredential(credential, challenge); // Store the credential details locally for demo purposes\r\n      console.log("Registration successful!", credential);\r\n      return credential; // Return the credential object containing the user\'s public key and other details\r\n    } catch (err) {\r\n      console.error("Registration failed:", err);\r\n      throw err; // Handle any errors that occur during registration\r\n    }\r\n  }\r\n\r\n  // Authenticates the user with stored credentials (like a fingerprint or Face ID)\r\n  async authenticate() {\r\n    const storedCredential = this.getStoredCredential(); // Retrieve stored credential information\r\n    if (!storedCredential) {\r\n      throw new Error("No stored credential found. Please register first."); // Error if no credentials are found\r\n    }\r\n\r\n    // PublicKeyCredentialRequestOptions is used to prompt the user to authenticate\r\n    const publicKey: PublicKeyCredentialRequestOptions = {\r\n      challenge: new Uint8Array(storedCredential.challenge), // A new challenge to ensure the request is fresh and unique\r\n      allowCredentials: [\r\n        {\r\n          // Specifies which credentials can be used for authentication\r\n          id: new Uint8Array(storedCredential.rawId), // The ID of the credential to use\r\n          type: "public-key",\r\n        },\r\n      ],\r\n      userVerification: "required", // Requires user verification (e.g., fingerprint or face scan)\r\n      timeout: 60000, // Timeout for the authentication operation in milliseconds\r\n    };\r\n\r\n    try {\r\n      // This will prompt the user to authenticate using their registered biometric credential\r\n      const credential = (await navigator.credentials.get({ publicKey })) as PublicKeyCredential;\r\n      console.log("Authentication successful!", credential);\r\n      return credential; // Return the credential object with authentication details\r\n    } catch (err) {\r\n      console.error("Authentication failed:", err);\r\n      throw err; // Handle any errors that occur during authentication\r\n    }\r\n  }\r\n\r\n  // Stores credential data in localStorage (for demo purposes only; this should be handled securely in production)\r\n  private storeCredential(credential: PublicKeyCredential, challenge: Uint8Array) {\r\n    const credentialData = {\r\n      rawId: Array.from(new Uint8Array(credential.rawId)), // Converts the raw ID to an array for storage\r\n      challenge: Array.from(challenge), // Converts the challenge to an array for storage\r\n    };\r\n    localStorage.setItem("webauthn_credential", JSON.stringify(credentialData)); // Store the data as a JSON string\r\n  }\r\n\r\n  // Retrieves stored credential data from localStorage\r\n  private getStoredCredential(): any {\r\n    const storedCredential = localStorage.getItem("webauthn_credential");\r\n    return storedCredential ? JSON.parse(storedCredential) : null; // Parse the stored JSON back into an object\r\n  }\r\n}\n'})})]})}function d(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);